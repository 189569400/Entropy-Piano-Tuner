#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "calculationprogressdialog.h"
#include "../core/messages/message.h"
#include "../core/messages/messagehandler.h"
#include "../core/messages/messagemodechanged.h"
#include "../core/messages/messageprojectfile.h"
#include "../core/messages/messagecorestatus.h"
#include "../core/messages/messagekeyselectionchanged.h"
#include <QDebug>
#include <QCloseEvent>
#include <QProcess>
#include <QMessageBox>
#include <QFileDialog>
#include <QToolButton>
#include <QStatusBar>
#include <QButtonGroup>
#include <QWhatsThis>
#include <QShortcut>
#include <QGuiApplication>
#include <QScreen>
#include <QCheckBox>
#include "logforqt.h"
#include "newtuningdialog.h"
#include "initializedialog.h"
#include "logviewer.h"
#include "autoconfiginputleveldialog.h"
#include "settingsforqt.h"
#include "options/optionsdialog.h"
#include "donotshowagainmessagebox.h"
#include "../core/tunerbase.h"

MainWindow::MainWindow(const QString &startUpFile, QWidget *parent) :
    QMainWindow(parent),
    mAudioRecorder(this),
    mAudioPlayer(this),
    mGuideScreenplay(this),
    ui(new Ui::MainWindow),
    mStartupFile(startUpFile.toStdString())
{
    mCore.reset(new Core(
                    new ProjectManagerForQt(this),
                    &mAudioRecorder,
                    &mAudioPlayer,
                    new LogForQt()));

    ui->setupUi(this);
    ui->fourierSpectrumGraphics->setKeyboard(ui->keyboardGraphicsView);
    ui->tuningCurveGraphicsView->setKeyboard(ui->keyboardGraphicsView);
    ui->volumeControlLevel->setAudioRecorder(&mAudioRecorder);

    ui->tuningInfoLayout->setAlignment(ui->measuredFrequencyLabel, Qt::AlignRight);
    ui->tuningInfoLayout->setAlignment(ui->deviationLabel, Qt::AlignRight);
    ui->tuningInfoLayout->setAlignment(ui->noteLabel, Qt::AlignRight);

    ui->mainToolBar->setIconSize(QSize(64, 64));



    QButtonGroup *group = new QButtonGroup(this);

    QToolButton *idleButton = new QToolButton(this);
    idleButton->setText(tr("Idle"));
    idleButton->setIcon(QIcon(":/images/mode_idle.png"));
    idleButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    idleButton->setCheckable(true);
    idleButton->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    idleButton->setWhatsThis(tr("Press this butten to switch to the idle mode."));
    group->addButton(idleButton);
    connect(idleButton, SIGNAL(toggled(bool)), this, SLOT(onModeIdle(bool)));
    ui->mainToolBar->addWidget(idleButton);

    QToolButton *recordingButton = new QToolButton(this);
    recordingButton->setText(tr("Record"));
    recordingButton->setIcon(QIcon(":/images/mode_record.png"));
    recordingButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    recordingButton->setCheckable(true);
    recordingButton->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    recordingButton->setWhatsThis(tr("Press this butten to switch to the recording mode."));
    group->addButton(recordingButton);
    connect(recordingButton, SIGNAL(toggled(bool)), this, SLOT(onModeRecord(bool)));
    ui->mainToolBar->addWidget(recordingButton);

    QToolButton *calculatingButton = new QToolButton(this);
    calculatingButton->setText(tr("Calculate"));
    calculatingButton->setIcon(QIcon(":/images/mode_calculate.png"));
    calculatingButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    calculatingButton->setCheckable(true);
    calculatingButton->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    calculatingButton->setWhatsThis(tr("Press this butten to switch to the calculation mode."));
    group->addButton(calculatingButton);
    connect(calculatingButton, SIGNAL(toggled(bool)), this, SLOT(onModeCalculate(bool)));
    ui->mainToolBar->addWidget(calculatingButton);

    QToolButton *tuningButton = new QToolButton(this);
    tuningButton->setText(tr("Tune"));
    tuningButton->setIcon(QIcon(":/images/mode_tune.png"));
    tuningButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    tuningButton->setCheckable(true);
    tuningButton->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    tuningButton->setWhatsThis(tr("Press this butten to switch to the tuning mode."));
    group->addButton(tuningButton);
    connect(tuningButton, SIGNAL(toggled(bool)), this, SLOT(onModeTune(bool)));
    ui->mainToolBar->addWidget(tuningButton);

    idleButton->setChecked(true);

    mModeToolButtons[MODE_IDLE] = idleButton;
    mModeToolButtons[MODE_RECORDING] = recordingButton;
    mModeToolButtons[MODE_CALCULATION] = calculatingButton;
    mModeToolButtons[MODE_TUNING] = tuningButton;

#ifdef __ANDROID__
    // show share button on android
    ui->actionShare->setVisible(true);
#endif

    ui->menuHelp->addAction(QWhatsThis::createAction(this));

    ui->actionGuide_enabled->setChecked(SettingsForQt::getSingleton().isGuideEnabled());

    updateVolumeBar();

    // create shortcuts
    new QShortcut(QKeySequence(Qt::Key_Up), ui->inputVolumeSpinBox, SLOT(stepUp()));
    new QShortcut(QKeySequence(Qt::Key_Down), ui->inputVolumeSpinBox, SLOT(stepDown()));
    new QShortcut(QKeySequence(Qt::Key_Tab), this, SLOT(onSelectNextMode()));
    new QShortcut(QKeySequence(Qt::SHIFT | Qt::Key_Tab), this, SLOT(onSelectPreviousMode()));

    qDebug() << QGuiApplication::primaryScreen()->physicalSize();
    if (QGuiApplication::primaryScreen()->physicalSize().width() < 150) {
        // smaller than 15 cm, use text abbrevs and hide some elements
        initForSmallScreen();
    }

    mCore.getProjectManager()->setCallback(this);

    // reset old settings (windows size/position and splitter)
    QSettings settings;
    restoreGeometry(settings.value("geometry/mainwindow").toByteArray());
    restoreState(settings.value("windowState/mainwindow").toByteArray());
    QList<int> sizes;
    for (QVariant v : settings.value("splitterSizes/graphSplitter").toList()) {
        sizes.push_back(v.toInt());
    }
    if (sizes.size() > 0) {
        ui->graphSplitter->setSizes(sizes);
    }
}

MainWindow::~MainWindow()
{
    mCore->exit();
    delete ui;
}

void MainWindow::init() {
    // disable main window during init
    this->setEnabled(false);

    // open initialize dialog
    //InitializeDialog *d = new InitializeDialog(this);
    // show it
    //d->show();
    // init the core with the dialog as callback
    mCore->init(0);

    // enable the main dialog again
    this->setEnabled(true);

    // and close the initialize dialog
    //d->close();

    // start the guide
    mGuideScreenplay.start();

    //delete d;

    // recativate window after closing the dialog
    activateWindow();
}

void MainWindow::setGuideActionEnabled(bool b)
{
    ui->actionGuide_enabled->setCheckable(b);
}

void MainWindow::closeEvent(QCloseEvent *event)
{
<<<<<<< Updated upstream
    if (mCore.getProjectManager()->onQuit()) {
        QSettings settings;
        settings.setValue("geometry/mainwindow", saveGeometry());
        settings.setValue("windowState/mainwindow", saveState());
        QVariantList sizes;
        for (int s : ui->graphSplitter->sizes()) {
            sizes.push_back(QVariant(s));
        }
        settings.setValue("splitterSizes/graphSplitter", sizes);



        mCore.exit();
        event->accept();     
        QMainWindow::closeEvent(event);
=======
    if (mCore->getProjectManager()->onQuit()) {
        mCore->exit();
        event->accept();
>>>>>>> Stashed changes
    } else {
        event->ignore();
    }
}

void MainWindow::handleMessage(MessagePtr m) {
    switch (m->getType()) {
    case Message::MSG_CORE_STATUS: {
        auto mcs(std::static_pointer_cast<MessageCoreStatus>(m));
        switch (mcs->getCoreStatusType()) {
        case MessageCoreStatus::CORE_INIT_END:
            coreInitialized();
            break;
        case MessageCoreStatus::CORE_STARTED:
            coreStarted();
            break;
        default:
            //WARNING("MessageCoreStatus::Type Not implemented");
            break;
        }
    }
    case Message::MSG_PROJECT_FILE: {
        auto mpf(std::static_pointer_cast<MessageProjectFile>(m));
        switch (mpf->getFileMessageType()) {
        case MessageProjectFile::FILE_CREATED:
            updateReferencePitch();
            statusBar()->showMessage(tr("File created"));
            break;
        case MessageProjectFile::FILE_EDITED:
            updateReferencePitch();
            statusBar()->showMessage(tr("File edited"));
            break;
        case MessageProjectFile::FILE_OPENED:
            statusBar()->showMessage(tr("File opened"));
            updateReferencePitch();
            break;
        case MessageProjectFile::FILE_SAVED:
            statusBar()->showMessage(tr("File saved"));
            break;
        default:
            WARNING("MessagePojectFile::Type Not implemented");
            break;
        }

        break;
    }

//    case Message::MSG_ANALYZE_SPECTRUM_STARTED:
//        statusBar()->showMessage(tr("Perform final spectral analysis"));
//        break;
//    case Message::MSG_ANALYZE_SPECTRUM_SUCCESSFULL:
//        updateMeasuredFrequency();
//        updateDeviation(TunerBase::SelectedKey);
//        ui->zoomedSpectrumGraphicsView->redraw();
//        break;
    case Message::MSG_ANALYZE_SPECTRUM_TOO_NOISY:
        statusBar()->showMessage(tr("Signal is too noisy. Please record again."));
        updateMeasuredFrequency();
        break;
    case Message::MSG_MODE_CHANGED: {
        auto mmc(std::static_pointer_cast<MessageModeChanged>(m));

        // check the correct tool button
        mModeToolButtons[mmc->getMode()]->setChecked(true);

        // hide all groups first and enable if required
        ui->tuningGroupBox->setVisible(false);
        ui->recordingGroupBox->setVisible(false);
        ui->calculationGroupBox->setVisible(false);
        ui->volumeGroupBox->setVisible(false);

        if (mmc->getMode() == MODE_IDLE) {
            ui->volumeGroupBox->setVisible(true);
        }

        if (mmc->getMode() == MODE_RECORDING) {
            ui->recordingGroupBox->setVisible(true);
            ui->volumeGroupBox->setVisible(true);
        }
        else {
        }

        if (mmc->getMode() == MODE_CALCULATION) {
            // hide first for correct sizing
            ui->startCalculationButton->setEnabled(true);
            ui->calculationGroupBox->setVisible(true);
            ui->fourierSpectrumGraphics->setVisible(false);
        } else {
            // hide first for correct sizing
            ui->startCalculationButton->setEnabled(false);
            ui->fourierSpectrumGraphics->setVisible(true);
        }

        if (mmc->getMode() == MODE_TUNING) {
            ui->tuningGroupBox->setVisible(true);
            ui->deviationLabel->setEnabled(true);
            ui->volumeGroupBox->setVisible(true);
        } else  {
            ui->deviationLabel->setEnabled(false);
            ui->deviationLabel->setText(QString("0"));
        }
        break;
    }
    case Message::MSG_KEY_RECORD_REQUESTING:
        statusBar()->showMessage(tr("Please press the key with a yellow mark."));
        break;
    case Message::MSG_KEY_RECORD_SUCCESSFULL_FORCED:
        statusBar()->showMessage(tr("Key set by force."));
        break;
    case Message::MSG_KEY_RECORD_SUCCESSFULL:
        statusBar()->showMessage(tr("Key successfully recorded."));
        break;
    case Message::MSG_KEY_RECORD_RENEWED:
        statusBar()->showMessage(tr("For renewed recording click key"));
        break;
    case Message::MSG_KEY_RECORD_REPEAT:
        statusBar()->showMessage(tr("Repeated recording not yet implemented"));
        break;
    case Message::MSG_RECORDING_STARTED:
        statusBar()->showMessage(tr("Recording keystroke"));
        break;
    case Message::MSG_RECORDING_ENDED:
        statusBar()->showMessage(tr("Recording stopped"));
        break;
    case Message::MSG_KEY_SELECTION_CHANGED: {
        auto mksc(std::static_pointer_cast<MessageKeySelectionChanged>(m));
        updateNoteName(mksc->getKey());
        break;}
    default:
        break;
    }
}

void MainWindow::changedInFileUpdated(bool) {
    updateWindowTitle();
}

void MainWindow::initForSmallScreen() {
    ui->label_inputLevel->setText(tr("Level"));
    ui->label_inputVolume->setText(tr("Volume"));
    ui->label_referencePitch->setText(tr("Pitch:"));
    ui->label_measuredFrequency->setText(tr("Freq.:"));
    ui->label_deviation->setText(tr("Dev.:"));

    // hide some elements
    ui->autoConfigureInputVolumeButton->setVisible(false);

    // some scaling issues
    ui->inputVolumeLayout->setStretch(0, 2);
    ui->inputVolumeLayout->setStretch(1, 1);
}

void MainWindow::updateNoteName(int8_t key) {
    QString text(QString::fromStdString(mCore->getPianoManager()->getPiano().getKeyboard().getNoteName(key)));
    // add super script to #
    text.replace("#", "<sup>#</sup>");
    //text.replace(QRegExp("([0-9])"), "<sub>\\1</sub>");
    ui->noteLabel->setText(text);
    ui->recordingCurrentKeyLabel->setText(text);
}

void MainWindow::updateMeasuredFrequency() {
    if (TunerBase::Frequency>1E-100) {
        std::stringstream ss2;
        // Show measured frequency
        if (TunerBase::Frequency<100) ss2.precision(2);
        else if (TunerBase::Frequency<1000) ss2.precision(1);
        else ss2.precision(0);
        ss2 << std::fixed << TunerBase::Frequency;

        ui->measuredFrequencyLabel->setText(QString(ss2.str().c_str()));
        ui->measuredFrequencyLabel->setText(QString("%L1").arg(TunerBase::Frequency, 5, 'f', 2));
    } else {
        ui->measuredFrequencyLabel->setText(QString());
    }
}

void MainWindow::updateDeviation(int8_t key) {

    std::stringstream ss3;
    auto ratiotocents = [] (double ratio) { return 1200*log(ratio)/log(2); };
    double deviation = ratiotocents(TunerBase::Frequency / TunerBase::getEqualTemperamentFrequency(key));
    ss3.precision(0);
    ss3 << (deviation>=0 ? "+ ":"- ") << std::fixed << std::abs(deviation);
    ui->deviationLabel->setText(QString(ss3.str().c_str()));
}

void MainWindow::updateReferencePitch() {
    ui->referencePitchLabel->setText(QString("%L1").arg(mCore->getPianoManager()->getPiano().getConcertPitch(), 5, 'f', 2));
}

void MainWindow::updateWindowTitle() {
    setWindowTitle(tr("Entropy piano tuner") + " - " + QString::fromStdString(mCore->getPianoManager()->getPiano().getName()) + (mCore->getProjectManager()->hasChangesInFile() ? "*" : ""));
}

void MainWindow::updateVolumeBar() {
    int max = 10000;
    int pos0 = AudioRecorderAdapter::PERCENTAGE_OFF * max;
    int pos1 = AudioRecorderAdapter::PERCENTAGE_ON * max;
    int pos2 = AudioRecorderAdapter::PERCENTAGE_CUT * max;

    ui->volumeControlLabelsLayout->setStretch(0, pos0);
    ui->volumeControlLabelsLayout->setStretch(1, pos1 - pos0);
    ui->volumeControlLabelsLayout->setStretch(2, pos2 - pos1);
    ui->volumeControlLabelsLayout->setStretch(3, max - pos2);

    ui->volumeControlLinesLayout->setStretch(0, pos0);
    ui->volumeControlLinesLayout->setStretch(1, 0);
    ui->volumeControlLinesLayout->setStretch(2, pos1 - pos0);
    ui->volumeControlLinesLayout->setStretch(3, 0);
    ui->volumeControlLinesLayout->setStretch(4, pos2 - pos1);
    ui->volumeControlLinesLayout->setStretch(5, 0);
    ui->volumeControlLinesLayout->setStretch(6, max - pos2);

    ui->inputVolumeSlider->setValue(round(std::log10(mAudioRecorder.getLevel()) * 20));
}

void MainWindow::onInputLevelIncrease() {
    mAudioRecorder.increaseLevel();
    ui->inputVolumeSlider->setValue(round(std::log10(mAudioRecorder.getLevel()) * 20));
}

void MainWindow::onInputLevelDecrease() {
    mAudioRecorder.decreaseLevel();
    ui->inputVolumeSlider->setValue(round(std::log10(mAudioRecorder.getLevel()) * 20));
}

void MainWindow::onInputLevelChanged(int dB) {
    ui->inputVolumeSpinBox->setValue(dB);
    ui->inputVolumeSlider->setValue(dB);

    mAudioRecorder.setLevel(std::pow(10, dB / 20.0));
}

void MainWindow::onOpenSoundControl() {
    QList<QPair<QString, QStringList> > programNames;
#ifdef __linux__
    programNames.append(qMakePair(QString("pavucontrol"), QStringList()));
    programNames.append(qMakePair(QString("gnome-control-center"), QStringList() << "sound"));
#elif __APPLE__
    // not supported yet
    programNames.append(qMakePair(QString("open"), QStringList() << "/System/Library/PreferencePanes/Sound.prefPane/"));
#elif _WIN32
    // untested, see http://support.microsoft.com/kb/192806/de
    programNames.append(qMakePair(QString("control"), QStringList() << "mmsys.cpl" << "sounds"));
#endif

#ifdef QT_NO_PROCESS
    // no processes allowed on the platform (e.g. windows RT)
#else
    QProcess *process = new QProcess(this);
    for (auto &program : programNames) {
        process->start(program.first, program.second);
        if (process->waitForStarted()) {
            INFORMATION("Sound control program '%s' started", program.first.toStdString().c_str());
            return;
        }
    }

    // no program could be started
    QMessageBox::warning(this, tr("Warning"), tr("Unable to find a supported sound conrol."));
#endif
}

void MainWindow::onStartCalculation() {
    CalculationProgressDialog d(this, getCore());
    d.exec();
}

void MainWindow::onAutoConfigureInputLevel() {
    // stop all signal processing before auto tuning
    AutoConfigInputLevelDialog d(&mAudioRecorder, this);
    d.exec();
    // signal analyzer will be started automatically
    updateVolumeBar();
}

void MainWindow::onFileNew() {
    mCore->getProjectManager()->onNewFile();
}

void MainWindow::onFileSave() {
    mCore->getProjectManager()->onSaveFile();
}

void MainWindow::onFileSaveAs() {
    mCore->getProjectManager()->onSaveFileAs();
}

void MainWindow::onFileOpen() {
    mCore->getProjectManager()->onOpenFile();
}

void MainWindow::onFileImportTextBasedFile() {
    mCore->getProjectManager()->onImport(ProjectManagerAdapter::TextBased);
}

void MainWindow::onFileShare() {
    mCore->getProjectManager()->onShare();
}

void MainWindow::onEditPianoDataSheet() {
    mCore->getProjectManager()->onEditFile();
}

void MainWindow::onResetRecording() {
<<<<<<< Updated upstream
    // message box
    if (DoNotShowAgainMessageBox::show(DoNotShowAgainMessageBox::RESET_RECORDING, this) == QMessageBox::Accepted) {
        mCore.getPianoManager()->clear();
    }
=======
    mCore->getPianoManager()->clear();
>>>>>>> Stashed changes
}

void MainWindow::onOptions() {
    options::OptionsDialog options(this);
    options.exec();
}

void MainWindow::onAbout() {
    QMessageBox::about(this, tr("About"), tr("Programmers: Haye Hinrichsen, Christoph Wick"));
}

void MainWindow::onViewLog() {
    LogViewer logViewer;
    logViewer.exec();
}

void MainWindow::onGuideEnabled(bool b) {
    SettingsForQt::getSingleton().enableGuide(b);
    mGuideScreenplay.guideActivated();
}

void MainWindow::onModeIdle(bool checked) {
    if (checked) {
        setMode(MODE_IDLE);
    }
}

void MainWindow::onModeRecord(bool checked) {
    if (checked) {
        setMode(MODE_RECORDING);
    }
}

void MainWindow::onModeCalculate(bool checked) {
    if (checked) {
        setMode(MODE_CALCULATION);
    }
}

void MainWindow::onModeTune(bool checked) {
    if (checked) {
        setMode(MODE_TUNING);
    }
}

void MainWindow::onSelectNextMode() {
    OperationMode mode = static_cast<OperationMode>((mCurrentMode + 1) % MODE_COUNT);
    mModeToolButtons[mode]->setChecked(true);
}

void MainWindow::onSelectPreviousMode() {
    OperationMode mode = static_cast<OperationMode>((mCurrentMode - 1 + MODE_COUNT) % MODE_COUNT);
    mModeToolButtons[mode]->setChecked(true);
}

void MainWindow::coreInitialized() {
    mCore->start();
}

void MainWindow::coreStarted() {
    updateReferencePitch();
    updateMeasuredFrequency();


    mCore->getProjectManager()->init(getCore(), mStartupFile);

    updateWindowTitle();
}
